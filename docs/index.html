<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Leaflet Map</title>

    <!-- import styling -->
    <link rel="stylesheet" href="css/leaflet.css"/>
    <link rel="stylesheet" href="css/custom.css"/>
    <!-- custom styling -->
    <style type="text/css">
      body{
        margin: 0;
        padding: 0;
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <!-- element that contains map -->
    <div id="map"></div>

    <!-- import packages -->
    <script src="js/leaflet.js"></script>

    <!-- load data -->
    <script src="data/axesofreconstruction_crs84.js"></script>
    <script src="data/featuretraces_crs84.js"></script>
    <script src="data/profileextents_crs84.js"></script>
    <script src="data/mapextents_crs84.js"></script>

    <!-- custom code for the leaflet map -->
    <script>
        // Map Object
        const map = L.map('map', {
            center: [36.85324009154614, 10.323104630306315],
            zoom: 18,
            zoomControl: true,
            maxZoom: 28,
            minZoom: 18
            });
        
        // Basemap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);

        // Styles
        var highlightStyle = {
          weight: 5,
          color: '#666',
          fillOpacity: 0.7
        }
        var defaultStyle = {
          color: 'blue'
        }
        var selectedStyle = {color: 'red'}
        var unselectedStyle = {color: '#dddde8'}

        // Interaction
        var selected = null;

        function onClick(e, geoJsonLayer) {
          // If something is not already selected, select it
          var layer = e.target;
          if (!selected) {
            layer.setStyle(selectedStyle);
            selected = true   // TODO: make this the actual selected feature
          }
          // Otherwise, deselect everything and reset their styles
          else {
            selected = null;
            geoJsonLayer.resetStyle();
            info.update();
          }
        }

        function highlightFeature(e) {
          if (!selected) {
            var layer = e.target;
            layer.setStyle(highlightStyle);


            // I'm not sure if this is necessary, but both GPT and
            // Stack Overflow (https://gis.stackexchange.com/q/227377)
            // suggested it
            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
              layer.bringToFront();
            }

            // Update the info control
            info.update(layer.feature.properties);
          }
        }

        function resetHighlight(e, geoJsonLayer) {
          if (!selected) {
                geoJsonLayer.resetStyle(e.target);
                info.update();
          }
        }

        function onEachFeature(feature, layer, geoJsonLayer) {
          // Note the distinction between `layer` and `geoJsonLayer` - only the
          // former has the resetStyle() method
          layer.on({
            click: function(e) {onClick(e, geoJsonLayer)},
            mouseover: highlightFeature,
            mouseout: function(e) {resetHighlight(e, geoJsonLayer)}
          });
        }

        // Add Data to map
        function addGeoJsonLayer(geoJsonData, map) {
          // Create a container layer to add interactivity to
          var geoJsonLayer = L.geoJSON(geoJsonData, {
            style: function () {
              return { color: 'blue' }; // Default style
            }
          }).addTo(map);

          // Interactivity has to be added with explicit reference to container
          geoJsonLayer.eachLayer(function(layer) {
            onEachFeature(layer.feature, layer, geoJsonLayer);
          });

          return geoJsonLayer;
        }

        // When you add a new GeoJSON layer, get the layer instance
        var myGeoJsonLayer = addGeoJsonLayer(featureTraces, map);

        // Info control
        var info = L.control();

        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info'); // create a div with the class "info"
          this.update();
          return this._div;
        }

        // Update info with new feature properties
        objectOrder = {
            'FeatureID': 1,
            'Constr': 2,
            'Period': 3,
            'Subperiod': 4,
            'Source': 5
        };

        function formatProperties (props, order) {
          // Re-order keys (need to copy order because it is used for checks below)
          const orderCopy = structuredClone(order)
          props = Object.assign(orderCopy, props)

          // Create formatted string - a table with a row for each property
          // Note: If on mobile, table can stretch whole screen width,
          //       otherwise it is limited to 0.25 of screen width.
          // TODO: allow user to adjust size of the table
          // TODO: fix vertical alignment, which is currently not working
          if (L.Browser.mobile) {
            str = "<table style=\"vertical-align:top\">"
          } else {
            str = "<table style=\"width:25vw; vertical-align:top\">"
          }
          for (let k of Object.keys(props)) {
            if (k in order) {
              row = "<tr><td><b>" + k + "</b></td><td>" + props[k] + "</td>"
              str = str + row
            }
          };
          str = str + "</table>"
          return str
        }

        regexs = {
          featureTrace: "[A-Z]{2}-[A-Z]{0,2}[0-9]{4}[reh]{1}",
          axis: "/AX-[0-9]{3}/g",
          figure: "/[A-Za-z0-9]{1,10}\.[A-Z]{1}\.[0-9]{3}[a-z]{1}/g",
        }
        function linkProperties (str) {

        }

        info.update = function (props) {
          this._div.innerHTML = '<h4>Feature Info</h4>' + (props ?
              formatProperties(props, objectOrder)
              : 'Hover over a feature');
        };

        info.addTo(map)
    </script>
    </body>
</html>
