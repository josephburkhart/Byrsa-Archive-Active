<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Leaflet Map</title>

    <!-- import styling -->
    <link rel="stylesheet" href="css/leaflet.css"/>
    <link rel="stylesheet" href="css/custom.css"/>
    <!-- custom styling -->
    <style type="text/css">
      body{
        margin: 0;
        padding: 0;
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <!-- element that contains map -->
    <div id="map"></div>

    <!-- import packages -->
    <script src="js/leaflet.js"></script>

    <!-- import custom scripts -->
    <script src="js/leaflink.js"></script>
    <script src="js/insertabletable.js"></script>
    <script src="js/splittablespan.js"></script>

    <!-- load data -->
    <script src="data/axesofreconstruction_crs84.js"></script>
    <script src="data/featuretraces_crs84.js"></script>
    <script src="data/profileextents_crs84.js"></script>
    <script src="data/mapextents_crs84.js"></script>

    <!-- custom code for the leaflet map -->
    <script>
        // Map Object
        const map = L.map('map', {
            center: [36.85324009154614, 10.323104630306315],
            zoom: 18,
            zoomControl: true,
            maxZoom: 28,
            minZoom: 18
            });
        
        // Basemap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);

        // Styles
        var highlightStyle = {
          weight: 5,
          color: '#666',
          fillOpacity: 0.7
        }
        var defaultStyle = {
          color: 'blue', 
          stroke: 'blue', 
          fillOpacity: 0.2,
          strokeWidth: 3
        };
        var selectedStyle = {
          color: 'red', 
          stroke: 'red', 
          fillOpacity: 0.5,
          strokeWidth: 5
      };

        // Interaction
        var selected = null;

        function onClick(e, geoJsonLayer) {
          // If something is not already selected, select it
          var layer = e.target;
          if (!selected) {
            layer.setStyle(selectedStyle);
            selected = [layer, geoJsonLayer]
            info.update(layer.feature.properties);
          }
          // Otherwise, deselect everything and reset their styles
          else {
            selected = null;
            geoJsonLayer.resetStyle();
            info.update();
          }
        }

        function highlightFeature(e) {
          if (!selected) {
            var layer = e.target;
            layer.setStyle(highlightStyle);


            // I'm not sure if this is necessary, but both GPT and
            // Stack Overflow (https://gis.stackexchange.com/q/227377)
            // suggested it
            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
              layer.bringToFront();
            }

            // Update the info control
            info.update(layer.feature.properties);
          }
        }

        function resetHighlight(e, geoJsonLayer) {
          if (!selected) {
                geoJsonLayer.resetStyle(e.target);
                info.update(null);
          }
        }

        // Store reference to layers for individual features with custom
        // id field layer as key
        // https://gis.stackexchange.com/a/367624
        let featureLayerCache = {};
        function cacheFeatureLayerById(feature, layer, idFieldName) {
          featureLayerCache[feature.properties[idFieldName]] = layer
        }

        function onEachFeature(feature, layer, geoJsonLayer, idFieldName) {
          // Note the distinction between `layer` and `geoJsonLayer` - only the
          // former has the resetStyle() method
          layer.on({
            click: function(e) {onClick(e, geoJsonLayer)},
            mouseover: highlightFeature,
            mouseout: function(e) {resetHighlight(e, geoJsonLayer)}
          });
          cacheFeatureLayerById(feature, layer, idFieldName);
        }

        // Add Data to map
        function addGeoJsonLayer(geoJsonData, map, idFieldName) {
          // Create a container layer to add interactivity to
          var geoJsonLayer = L.geoJSON(geoJsonData, {
            style: function () {
              return { color: 'blue' }; // Default style
            }
          }).addTo(map);

          // Interactivity has to be added with explicit reference to container
          geoJsonLayer.eachLayer(function(layer) {
            onEachFeature(layer.feature, layer, geoJsonLayer, idFieldName);
          });

          return geoJsonLayer;
        }

        // When you add a new GeoJSON layer, get the layer instance
        var myGeoJsonLayer = addGeoJsonLayer(featureTraces, map, "FeatureID");

        // Info control
        var info = L.control();

        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info'); // create a div with the class "info"
          let header = document.createElement("h4");
          header.innerText = "Feature Info";
          this._div.appendChild(header)

          // Note: If on mobile, div can stretch whole screen width,
          //       otherwise it is limited to 0.33 of screen width.
          // TODO: allow user to adjust size of the div
          let content = document.createElement("div");
          content.setAttribute("id", "control-info-content");
          if (!L.Browser.mobile) {
            content.setAttribute("style", "width:33vw");
          }
          content.innerHTML = "Hover over a feature";
          this._div.appendChild(content);
          return this._div;
        }

        // Update info with new feature properties
        objectOrder = {
            'FeatureID': 1,
            'Constr': 2,
            'Period': 3,
            'Subperiod': 4,
            'Source': 5
        };

        function formatProperties (props, order) {
          // Re-order keys (need to copy order because it is used for checks below)
          const orderCopy = structuredClone(order);
          props = Object.assign(orderCopy, props);
          
          // Filter out unordered fields
          const pick = (obj, arr) =>
            Object.fromEntries(Object.entries(obj).filter(([k]) => arr.includes(k)));
          props = pick(props, Object.keys(objectOrder));

          // Create table
          const nrows = Object.keys(props).length;
          const ncols = 2;
          const rowAtts = {style: "vertical-align:top"};
          table = makeInsertableTable(nrows, ncols, rowAtts);
          table.setAttribute("id", "properties-table")

          // Iterate over each field, adding links where necessary
          for (const [i, k] of Object.entries(Object.keys(props))) {
            let boldedKey = document.createElement("b");
            boldedKey.innerText = k;
            table.insert(data=boldedKey, rowIndex=i, colIndex=0);
            table.insert(data=linkProperties(props[k]), rowIndex=i, colIndex=1);
          }
          return table
        }

        const regexs = {
          "feature-trace": /[A-Z]{2}-[A-Z]{0,2}[0-9]{4}[reh]{1}/g,
          "axis": /AX-[0-9]{3}/g,
          "figure": /[A-Za-z0-9]{1,10}\.[A-Z]{1}\.[0-9]{3}[a-z]{0,1}-{0,1}[0-9]{0,1}/g,
        }
        function linkProperties (str) {
          // Return a span containing the original string, with links where the
          // linkable text originally was
          // TODO: should I just use the replaceWith method?
          if (str == null) {
            return document.createElement("span", {is: "splittable-span"});
          }
          let parentSpan = document.createElement("span", {is: "splittable-span"});
          parentSpan.textContent = str

          // Iterate over all types of links - TODO: change style of links based on their type
          let allMatches = {};
          for (linkType of Object.keys(regexs)) {
            const matches = str.match(regexs[linkType]);
            const uniqueMatches = [... new Set(matches)];
            const uniqueMatchesObject = Object.fromEntries(   //https://stackoverflow.com/a/53508215/15426433
              uniqueMatches.map(m => [m, linkType])
            );
            allMatches = Object.assign(allMatches, uniqueMatchesObject);
          }

          for (k of Object.keys(allMatches)) {
            const linkType = allMatches[k];
            const matchText = k;
            const link = document.createElement("leaf-link");

            link.clickCallback = function(e) {
              linkedFeatureLayer = featureLayerCache[link.getAttribute("link-text")];
              flashFeatureLayer(linkedFeatureLayer);
            };
            link.ctrlClickCallback = function(e) { 
              linkedFeatureLayer = featureLayerCache[link.getAttribute("link-text")];
              goToFeatureLayer(linkedFeatureLayer);
            };
            
            link.setAttribute("link-text", matchText);
            link.setAttribute("link-type", linkType);

            parentSpan.replaceStringWithElement(str=matchText, element=link);
          }
          return parentSpan
        }

        info.update = function (props) {
          // TODO: for some reason, this is called twice whenever the user
          //       mouses over a feature
          let content = document.getElementById("control-info-content");
          content.innerHTML = "";
          if (props) {
            content.appendChild(formatProperties(props, objectOrder));
          } else {
            content.innerHTML = "Hover over a feature";
          }
        }

        info.addTo(map)

        function flashFeatureLayer(featureLayer) {
          // TODO: make flash animation better
          featureLayer._path.style.animation = "flash-animation 1s ease-out";
          setTimeout(function() {
            featureLayer._path.style.animation = "";
          }, 1000);
        }

        function goToFeatureLayer(featureLayer) {
          // Zoom to target layer
          map.flyTo(featureLayer.getCenter());

          // Reset Selection
          selected[1].resetStyle();
          selected = null;

          // Reset info control
          info.update();

          // Click on target layer to select it
          featureLayer.fireEvent("click");
        }
    </script>
    </body>
</html>
