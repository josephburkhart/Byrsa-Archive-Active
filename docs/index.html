<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Leaflet Map</title>

    <!-- import styling -->
    <link rel="stylesheet" href="css/leaflet.css"/>
    <link rel="stylesheet" href="css/custom.css"/>
    <link rel="stylesheet" href="css/leaflet-ruler.css"/>

    <!-- custom styling -->
    <style type="text/css">
      body{
        margin: 0;
        padding: 0;
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <!-- element that contains map -->
    <div id="map"></div>

    <!-- import packages -->
    <script src="js/leaflet.js"></script>
    <script src="js/leaflet-ruler.js"></script>

    <!-- import custom scripts -->
    <script src="js/leaflink.js"></script>
    <script src="js/insertabletable.js"></script>
    <script src="js/splittablespan.js"></script>
    <script src="js/leaflet-title.js"></script>

    <!-- load data -->
    <script src="data/axesofreconstruction.js"></script>
    <script src="data/featuretraces.js"></script>
    <script src="data/mapextents.js"></script>

    <!-- custom code for the leaflet map -->
    <script>

        // ----------------------------- STYLING -------------------------------
        var highlightStyle = {
          weight:4.0,
          color: '#666',
          fillOpacity: 1.0
        }
        var selectedStyle = {
          color: 'red', 
          stroke: 'red', 
          fillOpacity: 0.5,
          weight:4.0
        };
        const conditionalStyles = {
          'Roman E Phase 1': {
            fillColor: '#34579c',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Roman R Phase 1': {
            fillColor: '#4fa1ff',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Roman H Phase 1': {
            fillColor: '#d8eafe',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Roman E Phase 2': {
            fillColor: '#cc5454',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Roman R Phase 2': {
            fillColor: '#ff9f2b',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Roman H Phase 2': {
            fillColor: '#ffebc0',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5,
            fill: true,
            lineCap: 'butt',
            lineJoin: 'miter',
            dashArray: ''
          },
          'Punic E': {
            fillColor: '#000000',
            color: '#969696',
            fillOpacity: 1.0,
            weight:1.5
          },
          'Punic R': {
            fillColor: '#969696',
            color: '#000000',
            fillOpacity: 1.0,
            weight:1.5
          }
        }
        let axesStyle = {
          color: '#2c6100',
          weight:1.5
        }
        let extentsStyle = {
          color: '#ad8eb0',
          fillOpacity: 0,
          weight:1.5
        }

        function flashFeatureLayer(featureLayer) {
            // TODO: make flash animation better
            featureLayer._path.style.animation = "flash-animation 1s ease-out";
            setTimeout(function() {
              featureLayer._path.style.animation = "";
            }, 1000);
        }

        function featureStyle(feature) {
          let p = feature.properties;
          if (p === undefined) {p = feature.feature.properties};  // I have no idea why this is necessary
          if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 1') && p['FeatureID'].slice(-1) === 'e') {
            return conditionalStyles['Roman E Phase 1'];
          } else if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 1') && p['FeatureID'].slice(-1) === 'r') {
            return conditionalStyles['Roman R Phase 1'];
          } else if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 1') && p['FeatureID'].slice(-1) === 'h') {
            return conditionalStyles['Roman H Phase 1'];
          } else if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 2') && p['FeatureID'].slice(-1) === 'e') {
            return conditionalStyles['Roman E Phase 2'];
          } else if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 2') && p['FeatureID'].slice(-1) === 'r') {
            return conditionalStyles['Roman R Phase 2'];
          } else if (p['Period'] === 'Roman' && p['Subperiod'].includes('Phase 2') && p['FeatureID'].slice(-1) === 'h') {
            return conditionalStyles['Roman H Phase 2'];
          } else if (p['Period'] === 'Punic' && p['FeatureID'].slice(-1) === 'e') {
            return conditionalStyles['Punic E'];
          } else if (p['Period'] === 'Punic' && p['FeatureID'].slice(-1) === 'r') {
            return conditionalStyles['Punic R'];
          }
        }
      
        // --------------------------- INTERACTION -----------------------------
        var selected = null;

        function onClick(e, geoJsonLayer) {
          // If something is not already selected, select it
          var layer = e.target;
          if (!selected) {
            layer.setStyle(selectedStyle);
            selected = [layer, geoJsonLayer]
            info.update(layer.feature.properties);
          }
          // Otherwise, deselect everything and reset their styles
          else {
            selected = null;
            geoJsonLayer.resetStyle();
            info.update();
          }
        }

        function highlightFeature(e) {
          if (!selected) {
            var layer = e.target;
            layer.setStyle(highlightStyle);


            // I'm not sure if this is necessary, but both GPT and
            // Stack Overflow (https://gis.stackexchange.com/q/227377)
            // suggested it
            // if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
            //   layer.bringToFront();
            // }

            // Update the info control
            info.update(layer.feature.properties);
          }
        }

        function resetHighlight(e, geoJsonLayer) {
          if (!selected) {
                geoJsonLayer.resetStyle(e.target);
                info.update(null);
          }
        }

        function onEachFeature(feature, layer, geoJsonLayer, idFieldName) {
          // Note the distinction between `layer` and `geoJsonLayer` - only the
          // former has the resetStyle() method
          layer.on({
            click: function(e) {onClick(e, geoJsonLayer)},
            mouseover: highlightFeature,
            mouseout: function(e) {resetHighlight(e, geoJsonLayer)}
          });
          cacheFeatureLayerById(feature, layer, idFieldName);
        }

        // --------------------------- MAP CONTROL -----------------------------
        function goToFeatureLayer(featureLayer) {
          // Zoom to target layer
          map.flyTo(featureLayer.getCenter());

          // Reset Selection
          selected[1].resetStyle();
          selected = null;

          // Reset info control
          info.update();

          // Click on target layer to select it
          featureLayer.fireEvent("click");
        }

        function cacheFeatureLayerById(feature, layer, idFieldName) {
        // Store reference to layers for individual features with custom
        // id field layer as key
        // https://gis.stackexchange.com/a/367624
          featureLayerCache[feature.properties[idFieldName]] = layer;
        }

        function addGeoJsonLayer(geoJsonData, map, style, idFieldName) {
          // Add a GeoJson Layer to the map
          // Create a container layer to add interactivity to
          var geoJsonLayer = L.geoJSON(geoJsonData, {
            style: style
          }).addTo(map);

          // Interactivity has to be added with explicit reference to container
          geoJsonLayer.eachLayer(function(layer) {
            onEachFeature(layer.feature, layer, geoJsonLayer, idFieldName);
          });

          return geoJsonLayer;
        }

        // --------------------------- FEATURE INFO ----------------------------
        // Regexs for use with info control; also determines the link type for
        // leaf-link
        const regexs = {
          "feature-trace": /[A-Z]{2}-[A-Z]{0,2}[0-9]{4}[reh]{1}/g,
          "axis": /AX-[0-9]{3}/g,
          "figure": /[A-Za-z0-9]{1,10}\.[A-Z]{1}\.[0-9]{3}[a-z]{0,1}-{0,1}[0-9]{0,1}/g,
        }

        // Info control
        var info = L.control();

        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info'); // create a div with the class "info"
          L.DomEvent.disableClickPropagation(this._div);
          let header = document.createElement("h4");
          header.innerText = "Feature Info";
          this._div.appendChild(header)

          // Note: If on mobile, div can stretch whole screen width,
          //       otherwise it is limited to 0.33 of screen width.
          // TODO: allow user to adjust size of the div
          let content = document.createElement("div");
          content.setAttribute("id", "control-info-content");
          if (!L.Browser.mobile) {
            content.setAttribute("style", "width:33vw");
          }
          content.innerHTML = "Hover over a feature";
          this._div.appendChild(content);
          return this._div;
        }

        info.update = function (props) {
          // TODO: for some reason, this is called twice whenever the user
          //       mouses over a feature
          let content = document.getElementById("control-info-content");
          content.innerHTML = "";
          if (props) {
            content.appendChild(formatProperties(props, objectOrder));
          } else {
            content.innerHTML = "Hover over a feature";
          }
        }
        
        // Update info with new feature properties
        objectOrder = {
            'FeatureID': 1,
            'Constr': 2,
            'Period': 3,
            'Subperiod': 4,
            'Source': 5,
            'FigureID': 6,
            'AxisID': 7,
            'descriptio': 8
        };
        fieldAliases = {
            'FeatureID': 'Feature ID',
            'Constr': 'Construction',
            'Period': 'Period',
            'Subperiod': 'Subperiod',
            'Source': 'Source',
            'FigureID': 'Figure ID',
            'AxisID': 'Axis ID',
            'descriptio': 'Description'
        }

        function formatProperties (props, order) {
          // Filter and sort the properties based on `order`
          // (method provided by GPT)
          props = Object.keys(props)
            .filter(key => Object.keys(order).includes(key))
            .sort((keyA, keyB) => order[keyA] - order[keyB])
            .reduce((acc, key) => {
              acc[key] = props[key];
              return acc;
            }, {});
          
          // Create table
          const nrows = Object.keys(props).length;
          const ncols = 2;
          const rowAtts = {style: "vertical-align:top"};
          table = makeInsertableTable(nrows, ncols, rowAtts);
          table.setAttribute("id", "properties-table")

          // Iterate over each field, adding links where necessary
          for (const [i, k] of Object.entries(Object.keys(props))) {
            let boldedKey = document.createElement("b");
            boldedKey.innerText = fieldAliases[k];
            table.insert(data=boldedKey, rowIndex=i, colIndex=0);
            table.insert(data=linkProperties(props[k]), rowIndex=i, colIndex=1);
          }
          return table
        }

        function linkProperties (str) {
          // Return a span containing the original string, with links where the
          // linkable text originally was
          // TODO: should I just use the replaceWith method?
          if (str == null) {
            return document.createElement("span", {is: "splittable-span"});
          }
          let parentSpan = document.createElement("span", {is: "splittable-span"});
          parentSpan.textContent = str

          // Iterate over all types of links - TODO: change style of links based on their type
          let allMatches = {};
          for (linkType of Object.keys(regexs)) {
            const matches = str.match(regexs[linkType]);
            const uniqueMatches = [... new Set(matches)];
            const uniqueMatchesObject = Object.fromEntries(   //https://stackoverflow.com/a/53508215/15426433
              uniqueMatches.map(m => [m, linkType])
            );
            allMatches = Object.assign(allMatches, uniqueMatchesObject);
          }
          for (k of Object.keys(allMatches)) {
            const linkType = allMatches[k];
            const matchText = k;
            const link = document.createElement("leaf-link");

            link.clickCallback = function(e) {
              linkedFeatureLayer = featureLayerCache[link.getAttribute("link-text")];
              flashFeatureLayer(linkedFeatureLayer);
            };
            link.ctrlClickCallback = function(e) { 
              linkedFeatureLayer = featureLayerCache[link.getAttribute("link-text")];
              goToFeatureLayer(linkedFeatureLayer);
            };
            
            link.setAttribute("link-text", matchText);
            link.setAttribute("link-type", linkType);
            parentSpan.replaceStringWithElement(
              str=matchText, 
              element=link,
              cloneCallback=function() { return link.cloneWithCallbacks() }
            );
          }
          return parentSpan
        }

        // --------------------------- CREATE MAP ------------------------------
        const map = L.map('map', {
            center: [36.85324009154614, 10.323104630306315],
            zoom: 18,
            zoomControl: true,
            maxZoom: 28,
            minZoom: 5,
            zoomControl: false
            });
        
        // Basemap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);

        // Container for use with cacheFeatureLayerById()
        let featureLayerCache = {};

        // When you add a new GeoJSON layer, get the layer instance
        let featureTraceGeoJsonLayer = addGeoJsonLayer(featureTraces, map, featureStyle, "FeatureID");
        let axesGeoJsonLayer = addGeoJsonLayer(axesOfReconstruction, map, axesStyle, "AxisID");

        // Create map extents layer that only plots the outlines of the features
        // Method adapted from output of GPT
        let extentsFeatures = [];
        mapExtents.features.forEach(function(feature) {
          let properties = feature.properties;
          let coordinates = feature.geometry.coordinates[0][0];
          let polylineFeature = {
            "type": "Feature",
            "properties": properties,
            "geometry": {
              "type": "LineString",
              "coordinates": coordinates
            }
          };
          extentsFeatures.push(polylineFeature);
        });
        let extentsOutlinesGeoJSON = {
          "type": "FeatureCollection",
          "features": extentsFeatures
        }
        mapExtentsGeoJsonLayer = addGeoJsonLayer(extentsOutlinesGeoJSON, map, extentsStyle, "FigureID");

        
        // Title
        let titleOptions = {
          position: 'topleft',
          text: 'The Byrsa Hill'
        }
        L.control.title(titleOptions).addTo(map);

        // Zoom Control
        L.control.zoom().addTo(map);
        
        // TODO: add grid cells
        // Feature info widget
        info.addTo(map)

        // Measure Tool
        let rulerOptions = {
          position: "topleft",
          lineStyle: {
            color: 'yellow',
            dashArray: '1,6'
          },
          lengthUnit: {
            display: 'm',
            decimal: 2,
            factor: 1000,
            label: 'Distance:'
          }
        }
        L.control.ruler(rulerOptions).addTo(map);
    </script>
    </body>
</html>
